---
layout: docs
title: Binary Files
---

<div markdown="1" class="d-none d-xl-block col-xl-2 order-last bd-toc">

- [Introduction](#introduction)
- [Example with http](#example-with-http)
  - [POST a binary file](#post-a-binary-file)
  - [Uploading files with PUT](#uploading-files-with-put)
  - [The "properties" part](#the-properties-part)
  - [GET a binary file](#get-a-binary-file)
- [Using httpie](#using-httpie)

</div>
<div markdown="1" class="col-12 col-md-9 col-xl-8 py-md-3 bd-content">

{% include docs-head.html %}

{% include doc-in-progress.html %}

## Introduction

RESTHeart is a very good fit for **headless CMS** use cases, as it allows to effectively manage and aggregate content and its metadata, such as images, audios and videos, delivering them via a REST API.

{: .alert.alert-info }
RESTHeart offers complete binary files management. It's possible to **create**, **read** and **delete** even huge files. RESTHeart makes use of MongoDB's **GridFS**, a specification for storing and retrieving files that exceed the BSON-document size limit of 16 MB.

You can read more about GridFS [here](https://docs.mongodb.org/manual/core/gridfs/).

## Example with http

Let's use [httpie](https://httpie.org) to upload a PNG image named "[dataflow.png](/images/dataflow.png)"

{: .bs-callout.bs-callout-warning }
__Note__: RESTHeart's HTTP clients must adhere to the **multipart/form-data** specification. However the specification allows a form to upload multiple files at the same time, but RESTHeart prohibits that: while it's possible to POST / PUT several different non-binary parts for each file, it's mandatory to upload one single binary file per each POST / PUT request. This limitation is necessary to univocally relate all the optional parts to the unique file.

### POST a binary file

{: .bs-callout.bs-callout-success }
In this example we assume RESTHeart is running on `localhost`, port `8080`.

Create the default `restheart` database, if none exists yet:

```bash
$ http -a admin:secret PUT :8080/

HTTP/1.1 200 OK
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: *
Access-Control-Expose-Headers: Location, ETag, X-Powered-By
Auth-Token: 1o6j8dt1f5y6jlu05t0blw2q4g280cgdv8253ilqhyoskoi5de
Auth-Token-Location: /tokens/admin
Auth-Token-Valid-Until: 2019-07-04T09:24:37.171231Z
Connection: keep-alive
Content-Length: 0
Content-Type: application/json
Date: Thu, 04 Jul 2019 09:09:37 GMT
ETag: 5d1dc2510951267987cf8ab1
X-Powered-By: restheart.org
```

Create the collection for hosting files. It must end with `.files` to
mark this as a special collection for files:

```bash
$ http -a admin:secret PUT :8080/mybucket.files

HTTP/1.1 201 Created
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: *
Access-Control-Expose-Headers: Location, ETag, X-Powered-By
Auth-Token: 1o6j8dt1f5y6jlu05t0blw2q4g280cgdv8253ilqhyoskoi5de
Auth-Token-Location: /tokens/admin
Auth-Token-Valid-Until: 2019-07-04T09:26:41.654633Z
Connection: keep-alive
Content-Length: 0
Content-Type: application/json
Date: Thu, 04 Jul 2019 09:11:41 GMT
ETag: 5d1dc2cd0951267987cf8ab2
X-Powered-By: restheart.org
```

Then POST the file:

```bash
$  http -a admin:secret -f POST :8080/mybucket.files dataflow@dataflow.png

HTTP/1.1 201 Created
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: *
Access-Control-Expose-Headers: Location, ETag, X-Powered-By
Auth-Token: 5r9jcdp1yzfa1uwx0nety86bgwz5fq5wmd17qjjajcbxw5ptzy
Auth-Token-Location: /tokens/admin
Auth-Token-Valid-Until: 2019-07-05T07:08:09.510520Z
Connection: keep-alive
Content-Length: 0
Content-Type: application/json
Date: Fri, 05 Jul 2019 06:53:10 GMT
Location: http://localhost:8080/mybucket.files/5d1ef3d50951267987cf8ab4
X-Powered-By: restheart.org
```

The request above is the same as if the following HTML form were submitted:

````html
<form enctype="multipart/form-data" method="post" action="http://localhost:8080/mybucket.files">
    <input type="file" name="dataflow" />
</form>
```

The `Location` HTTP header returns the file's location:

```text
Location: http://localhost:8080/mybucket.files/5d1ef3d50951267987cf8ab4
```

{: .alert.alert-info }
Note that the location contains the object ID automatically generated by
MongoDB (see the string `5d1ef3d50951267987cf8ab4` at the end of the
above Location URL). This is a unique identifier and it's convenient in many
situation, but it's not always desirable. In many case it would be
better to explicitly name the resource with something more readable and
meaningful. To set the resource name it is necessary to upload the file
by using the PUT verb instead of POST. We'll show this later.

If you GET the `Location`, RESTHeart actually returns the file's metadata:

```
$ http -a admin:secret http://localhost:8080/mybucket.files/5d1ef3d50951267987cf8ab4

HTTP/1.1 200 OK
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: *
Access-Control-Expose-Headers: Location, ETag, X-Powered-By
Auth-Token: 5r9jcdp1yzfa1uwx0nety86bgwz5fq5wmd17qjjajcbxw5ptzy
Auth-Token-Location: /tokens/admin
Auth-Token-Valid-Until: 2019-07-05T07:15:17.848962Z
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 244
Content-Type: application/json
Date: Fri, 05 Jul 2019 07:00:17 GMT
ETag: 5d1ef3d50951267987cf8ab3
X-Powered-By: restheart.org

{
    "_id": {
        "$oid": "5d1ef3d50951267987cf8ab4"
    }, 
    "_links": {
        "rh:data": {
            "href": "/mybucket.files/5d1ef3d50951267987cf8ab4/binary"
        }
    }, 
    "chunkSize": 261120, 
    "filename": "file", 
    "length": {
        "$numberLong": "232201"
    }, 
    "md5": "543dacb294d6fad4eb019b33b7192a4d", 
    "metadata": {
        "_etag": {
            "$oid": "5d1ef3d50951267987cf8ab3"
        }, 
        "contentType": "image/png"
    }, 
    "uploadDate": {
        "$date": 1562309590133
    }
}
```

The axctual binary content is available by appending the `binary` postfix, like this:

```
http://localhost:8080/mybucket.files/5d1ef3d50951267987cf8ab4/binary
```

Note that the browser might show a popup window asking for credentials. As usual, use `admin:secret`.

{: .bs-callout.bs-callout-warning }
Once a file has been created it becomes **immutable**: only its metadata can be updated. Practically, to update an existing file it's necessary to delete and re-create it.

### Uploading files with PUT

In the previous examples, the `mybucket.files` owner by default assigned to new files a resource name coming from MongoDB. If we want to set a meaningful URL then we need to send a PUT, like this:

```bash
http -a admin:secret -f PUT :8080/mybucket.files/dataflow.png dataflow@dataflow.png

HTTP/1.1 201 Created
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: *
Access-Control-Expose-Headers: Location, ETag, X-Powered-By
Auth-Token: 5r9jcdp1yzfa1uwx0nety86bgwz5fq5wmd17qjjajcbxw5ptzy
Auth-Token-Location: /tokens/admin
Auth-Token-Valid-Until: 2019-07-05T07:24:04.146509Z
Connection: keep-alive
Content-Length: 0
Content-Type: application/json
Date: Fri, 05 Jul 2019 07:09:04 GMT
X-Powered-By: restheart.org

```

If we GET the resulting resource, here is the full HTTP response:

```bash
$ http -a admin:secret :8080/mybucket.files/dataflow.png

HTTP/1.1 200 OK
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: *
Access-Control-Expose-Headers: Location, ETag, X-Powered-By
Auth-Token: 5r9jcdp1yzfa1uwx0nety86bgwz5fq5wmd17qjjajcbxw5ptzy
Auth-Token-Location: /tokens/admin
Auth-Token-Valid-Until: 2019-07-05T07:39:57.206643Z
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 246
Content-Type: application/json
Date: Fri, 05 Jul 2019 07:24:57 GMT
ETag: 5d1ef4f50951267987cf8ab6
X-Powered-By: restheart.org

{
    "_id": "dataflow.png", 
    "_links": {
        "rh:data": {
            "href": "/mybucket.files/dataflow.png/binary"
        }
    }, 
    "chunkSize": 261120, 
    "filename": "file", 
    "length": {
        "$numberLong": "232201"
    }, 
    "md5": "543dacb294d6fad4eb019b33b7192a4d", 
    "metadata": {
        "_etag": {
            "$oid": "5d1ef4f50951267987cf8ab6"
        }, 
        "contentType": "image/png"
    }, 
    "uploadDate": {
        "$date": 1562309877118
    }
}

```

Note that in this case the resource shows a much nicer URL:

```plain
http://localhost:8080/mybucket.files/dataflow.png
```

Which is easier to read and link than the automatically generated name.


### The "properties" part

It's possible to add more form data parts to the request

```bash
$ 
```

The JSON will be merged into the file document (look at the end of the
code block):

Expand source

```bash
TTP/1.1 200 OK
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: *
Access-Control-Expose-Headers: Location, ETag, Auth-Token, Auth-Token-Valid-Until, Auth-Token-Location, X-Powered-By
Auth-Token: 4tplfhpu5uy5hq1ih4r2tg2f1b9kygp4sypr1oe7yvr3fby43d
Auth-Token-Location: /_authtokens/admin
Auth-Token-Valid-Until: 2018-04-08T21:44:08.928Z
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 270
Content-Type: application/json
Date: Sun, 08 Apr 2018 21:29:08 GMT
ETag: 5aca899f634459000711d933
X-Powered-By: restheart.org

{
    "_id": {
        "$oid": "552e1e89e4b019b2fa790f3f"
    },
    "_links": {
        "rh:data": {
            "href": "/db/mybucket.files/552e1e89e4b019b2fa790f3f/binary"
        }
    },
    "chunkSize": 261120,
    "filename": "file",
    "length": {
        "$numberLong": "220973"
    },
    "md5": "0f289f7447e9db7af996e112e8fe3de1",
    "metadata": {
        "_etag": {
            "$oid": "5aca899f634459000711d933"
        },
        "contentType": "image/png",
        "name": "Maurizio",
        "surname": "Turatti"
    },
    "uploadDate": {
        "$date": 1523222943247
    }
}
```

If the "properties" part contains a "filename" this sets
the filename.

then passing the following part

`'properties={"filename":"different_filename.png"}'`

### GET a binary file

GET the representation (metadata only) for the newly created file:

```bash
$ http -a admin:secret http://:8080/mybucket.files/552e1e89e4b019b2fa790f3f
```

Appending \``/binary`\` at the end of the above URL makes possible to
GET the binary content stored into GridFS:

```bash
$ http -a admin:secret http://:8080/mybucket.files/552e1e89e4b019b2fa790f3f/binary
```

If we paste this URL to a browser's address bar then the image is
displayed. This allows RESTHeart to serve as a very basic but powerful
digital asset management system.

![](/images/attachments/11567174/13107220.png?width=800){width="800"}

As explained, the underlying storage mechanism is MongoDB's GridFS,
which is an extremely powerful abstraction over a filesystem, without
any file size limits.

When should I use GridFS?

For documents in a MongoDB collection, you should always use GridFS for
storing files larger than 16 MB.

In some situations, storing large files may be more efficient in a
MongoDB database than on a system-level filesystem.

- If your filesystem limits the number of files in a directory, you
  can use GridFS to store as many files as needed.
- When you want to keep your files and metadata automatically synced
  and deployed across a number of systems and facilities. When using
  geographically distributed replica sets MongoDB can distribute files
  and their metadata automatically to a number of mongod instances and
  facilities.
- When you want to access information from portions of large files
  without having to load whole files into memory, you can use GridFS
  to recall sections of files without reading the entire file into
  memory.

[Read
More](https://docs.mongodb.org/manual/faq/developers/#faq-developers-when-to-use-gridfs).

## Using httpie

While http does its job, instead we
love [httpie](https://github.com/jakubroztocil/httpie). This little
Python program allows to indent and colorize the output of HTTP
responses, making it more readable than http.

Let's say we already have a db called `testdb`, exactly as with http,
first create the `.files` collection, if it doesn't exist yet:

```bash
http -a admin:secret -j PUT :8080/mybucket.files
```

Then POST a file named "dataflow.png":

```bash
http -a admin:secret -f POST :8080/mybucket.files file@dataflow.png;filename=dataflow.png
```

For example, to upload a file named "mypicture.png" with PUT:

```bash
http -a admin:secret -f PUT :8080/mybucket.files/mypicture.png file@"~/Desktop/mypicture.png" properties='{"author":"Maurizio Turatti"}'
```

</div>
